\chapter{Top-k closeness for dynamic graphs}
\label{ch:dynamicCloseness}

Many algorithms from the field of network analysis, including the algorithms from Chapter~\ref{ch:staticCloseness}, are designed to be run only once on a static graph. This does not match the requirements of many real-world applications. In social networks like Facebook or Twitter, the underlying social graph changes constantly. There are always new users who join a social network, some others leave; existing users befriend other users or end virtual friendships. The structure of the underlying social graph always changes, and therefore every metric in the network also changes.

The na\"ive approach to update these metrics is to simply run the corresponding static algorithm again after the graph has changed. The problem with this approach is that information obtained in previous runs is disregarded and the runtime of the algorithm will be roughly the same as before. In practice, modifying a single edge in the graph will often not affect all nodes in the graph. Depending on the metric and the corresponding algorithm, nodes unaffected by a modification can then simply be skipped to reduce the overall runtime.

In this thesis, we will present two new dynamic algorithms. The first one is based on the static algorithm for complex networks by Borassi et al. (see Section~\ref{sec:topKClosenessComplex}). The second one is based on the static algorithm for networks with large diameter by Bergamini et al. (see Section~\ref{sec:largeDiameterStatic}).

\section{Preliminaries}
Let $G(V, E)$ denote an unweighted graph $G$ with the set of nodes $V$ and the set of edges $E$. For simplicity, we will use the notation $(u, v)$ for an edge between two nodes $u$ and $v$ interchangeably for directed and undirected edges. We can define an \emph{edge insertion} as a function $f_i$, such that
\begin{align}
	f_i(G(V, E), (u, v)) = G'(V, E \cup (u, v))\text{ with } (u, v) \notin E.
\end{align}
An \emph{edge removal} is defined as a function $f_r$, such that
\begin{align}
	f_r(G(V, E), (u, v)) = G'(V, E \setminus (u, v)) \text{ with } (u, v) \in E.
\end{align}
We will use \emph{edge modification} as a collective term for both edge insertions and edge removals. We do not consider node modifications in this thesis because adding or removing isolated nodes does not affect the closeness centralities of the other nodes in the graph. Further, removing a node that is not isolated is equivalent to first removing all of its incident edges one-by-one and then removing an isolated node. Inserting a node with a set of incident edges can also be split into two parts: adding an isolated node and then adding the incident edges one-by-one.

We also define the \emph{distance to the edge modification} as $d_G^f(w, (u, v)) := \min{(d_G(w, u), d_G(w, v))}$ for undirected graphs. In directed graphs, only the distance to the source node $u$ of the edge is relevant and we get $d_G^f(w, (u, v)) = d_G(w, u)$.

\todo{Short section about dynamic closeness}

\section{Dynamic Top-k closeness}
We will now describe two new algorithms to update the list of the $k$ most central nodes in a graph after an edge modification. The first algorithm is based on the static algorithm by Borassi et al. presented in Section~\ref{sec:topKClosenessComplex}. It works especially well on networks with small diameter. The second algorithm is based on the static algorithm for networks with large diameter by Bergamini et al. which is described in Section~\ref{sec:largeDiameterStatic}. The adaptations of both algorithms for the dynamic case both follow the static version closely. However, the dynamic versions will try to use previously collected information in order to skip some of the work the static versions have to do.

In general, it makes sense to only process nodes which are actually \emph{affected} by an edge modification. 

\subsection{Affected nodes}

Transforming a graph $G$ to $G'$ by inserting or removing edges will change the distances between some node pairs, and thus change the closeness centralities of these nodes.

\subsubsection{Definition and observations}

\begin{definition}
\label{def:affectedNodes}
	Let $G = (V, E)$ denote an unweighted graph and $G' = f(G)$ a modified version of $G$ with $f \in \{f_i, f_r\}$. Then the nodes in 
	\begin{align}
		A_G^f(u, v) &= \{s \in V \mid \exists t \in V : d_G(s,t) \neq d_{G'}(s, t)\} \label{eq:affectedNodesGeneral} \\
		            &=\{s \in V \mid d_G(s, v) \neq d_{G'}(s, v) \lor d_G(s, u) \neq d_{G'}(s, u)\} \label{eq:affectedNodesSimplified}
	\end{align} are called \textbf{affected nodes}.
\end{definition}
 
First, we consider the insertion of the edge $(u, v)$. In undirected graphs, both $u$ and $v$ will obviously be affected by this edge insertion because their new distance will be $1$ while it had to be at least $2$ before the insertion. In directed graphs, only $u$ will be affected. Now consider two nodes $s$ and $t$ with $d_G(s, t) > d_G(s, u) + d_G(v, t) + 1$. After inserting $(u, v)$, the new shortest path will use the new edge. The length of the new path is then $d_{G'}(s, t) = d_G(s, u) + d_G(v, t) + 1$. In general, every new shortest path has to contain the edge $(u, v)$.

In the case of an edge removal, the distance between two nodes $s$ and $t$ only changes if all the shortest paths between the two nodes contain the removed edge. This makes both operations symmetrical. After an edge insertion, all new shortest paths contain the inserted edge. If the edge is subsequently removed, only these shortest paths cease to exist.

We noted earlier that each new shortest path or each erased shortest path must always contain the modified edge. We will call these shortest paths \emph{affected shortest paths}. Each affected shortest path must contain the node sequence $u - v$. In undirected graphs, we can always switch the direction of a path such that $u$ and $v$ appear in this order.

For any node $s \in A_G^f(u, v)$, we only need to know whether there is at least one affected shortest path which starts in that node. Each affected shortest path contains the sequence $u - v$ and the distance between both nodes changes after modifying the edge $(u, v)$. Therefore, the distance to either $u$ or $v$ will change for each affected node. Therefore, Equation~\ref{eq:affectedNodesGeneral} can be rewritten to Equation~\ref{eq:affectedNodesSimplified}. We note that in the directed case, there are no nodes $s$ for which $d_G(s, u) \neq d_{G'}(s, u)$. Equation~\ref{eq:affectedNodesSimplified} can be rewritten for directed graphs as
\begin{align}
	A_G^f(u, v) = \{s \in V \mid d_G(s, v) \neq d_{G'}(s, v)\} \label{eq:affectedNodesSimplifiedDirected}.
\end{align}

Figure~\ref{fig:affectedNodes} shows an example of an edge modification. The nodes affected by either removing or inserting the dashed edge between $u$ and $v$ are marked in red.


\begin{figure}[h!]
\centering
\begin{tikzpicture}
	\tikzset{edge/.style = {-,> = latex'}}
	
    \node[main node,fill=red!50] (1) {};
    \node[main node,fill=white] (2) [below = 2cm of 1]  {};
    \node[main node,fill=red!50] (3) [right = 2cm of 1] {$u$};
    \node[main node,fill=white] (4) [below = 2cm of 3] {};
    \node[main node,fill=red!50] (5) [below right = 1cm and 2cm of 3] {$v$};
    \node[main node,fill=white] (6) [right = 2cm of 5] {};
    \node[main node,fill=white] (7) [right = 2cm of 6] {};
    \node[main node,fill=white] (8) [above = 2cm of 3] {};
    
	\draw[edge] (1) to (2);
	\draw[edge] (1) to (3);
	\draw[edge] (2) to (4);
	\draw[edge] (4) to (5);
	\draw[edge] (3) to (2);
	\draw[edge] (3) to (4);
	\draw[dashed] (3) to (5);
	\draw[edge] (5) to (6);
	\draw[edge] (6) to (7);
	\draw[edge] (3) to (8);
	\draw[edge] (6) to[bend right] (8);
\end{tikzpicture}
\caption{Affected and unaffected nodes}{The nodes marked in red will be affected if the edge between $u$ and $v$ is modified.}
\label{fig:affectedNodes}
\end{figure}



\subsubsection{Computing affected nodes}
\paragraph{Directed graphs}
In directed graphs, each affected shortest path contains the exact sequence $u - v$. Therefore, we only need to find those nodes for which the distance to $v$ changes (see Figure~\ref{fig:affectedNodesDirectedBfs}). Algorithm~\ref{alg:affectedNodesDirected} computes this set of nodes for an edge insertion on a directed graph.

Let $G^-$ denote the graph $G$ without the edge $(u, v)$, let $G^{+}$ denote the graph $G$ that contains the edge $(u, v)$. We first run a reverse BFS (following incoming edges) on $G^-$ starting from $v$ and store the distances to each node in the graph (Line~\ref{alg:reverseBFSCall}).

We then execute a second reverse BFS starting in $v$, this time on $G^{+}$. This pruned reverse BFS is shown in Algorithm~\ref{alg:prunedReverseBFS}. It is supplied with the graph $G^{+}$, the source node for the reverse BFS $s$ and an array $d^-$ containing the distances between $s$ and each other node in the graph that does not contain the modified edge. We use a modified version of the standard algorithm which adds subtree pruning to avoid a full search. If we visit a new node $w$, we check if its distance to the source node is smaller than the old distance (Line~\ref{alg:reverseBFSPruning}). If the new distance is smaller than the old distance, we add $w$ to the set of affected nodes and to the search queue. This technique allows us to skip subtrees that have not changed due to the edge modification.

It is not practical to construct separate instances $G^-$ and $G^{+}$ of the graph when dealing with real-world networks. It is reasonable to assume that the underlying application only holds one instance of the graph. For instance, in the case of an edge removal, the underlying graph will no longer contain the removed edge when the update algorithm is called. This means that the underlying graph is equal to $G^-$. Therefore, the first reverse BFS can be executed without any further adjustments. However, the removed edge has to be added back virtually for the second BFS which is run on $G^{+}$. This is done by adding the old neighbor $u$ to the search queue before the search starts. This is shown in Lines~\ref{alg:addingAdditionalNeighbor}-\ref{alg:addingAdditionalNeighborEnd} of Algorithm~\ref{alg:prunedReverseBFSRemovals}.

\paragraph{Undirected graphs}
Finding the affected nodes on undirected graphs requires more computational effort. As illustrated in Figure~\ref{fig:affectedNodesUndirectedBfs}, those nodes can either have a different distance to $u$ or to $v$. In the undirected case, we basically run the algorithm from the directed case twice. Once we start the breadth-first searches from $u$ and and once from $v$. The set of the affected nodes is the union of all nodes whose distance to either $u$ or $v$ is different in $G^-$ and $G^{+}$.

\begin{algorithm2e}[h!]
 \label{alg:affectedNodesDirected}
 \KwData{$G = (V, E), (u, v)$: the modified edge}
 \KwResult{$A_G^f(u, v)$}
   \tcc{Construct $G^-$ and $G^{+}$}
   \eIf{$(u, v) \in E$}{
   		$G^- \gets (V, E \setminus \{(u, v)\})$ \\
   		$G^{+} \gets (V, E)$
   }{
   	    $G^- \gets (V, E)$ \\
   	    $G^{+} \gets (V, E \cup \{(u, v)\})$
   }
   
   \tcc{like a normal BFS, but following incoming edges}
   $d^- \gets \texttt{ReverseBFS(G - (u, v), v)}$ \label{alg:reverseBFSCall} \\
   
   $A_G^f(u, v) \gets$ \texttt{PrunedReverseBFS($G + (u, v)$, $d^-$, $v$)}
   
 \caption{Computing affected nodes in directed graphs.}
\end{algorithm2e}



\begin{algorithm2e}[h!]
 \label{alg:prunedReverseBFS}
 \KwData{$G = (V, E), d^-, s$}
 \KwResult{$A_G^f(u, v)$}
   $A_G^f(u, v) \gets \emptyset$
   
   \tcc{FIFO queue}
   $Q \gets \{s\}$  \\  
   
   $d \gets $ array storing the distances of the nodes \\
   $d[s] \gets 0$ \\
   Mark $s$ as visited \\
   \While{$Q$ is not empty}{
     $u \gets $ first node from $Q$
     
     \ForAll{$w \in N^{\leftarrow}(u)$}{
       \If{$w$ is not marked as visited}{
         $d[w] \gets d[u] + 1$ \\
         Mark $w$ as visited \\
         \If{$d^-[w] < d[w]$}{ \label{alg:reverseBFSPruning}
           $A_G^f(u, v) \gets A_G^f(u, v) \cup \{w\}$ \\
           Enqueue $w$ in $Q$
         }
       }
     
     }
     
   }
   
   return $A_G^f(u, v)$ 
   
 \caption{\texttt{PrunedReverseBFS}}
\end{algorithm2e}

\begin{algorithm2e}[h!]
 \label{alg:prunedReverseBFSRemovals}
 \KwData{$G = (V, E), d^-, s, (u, v) \notin E$}
 \KwResult{$A_G^f(u, v)$}
   $A_G^f(u, v) \gets \emptyset$
   
   \tcc{FIFO queue}
   $Q \gets \{s\}$ \\
   $d \gets $ array storing the distances of the nodes \\
   $d[s] \gets 0$ \\
   mark $s$ as visited \\
   
   \tcc{Virtually add back the old neighbor $u$}
   Enqueue $u$ in $Q$ \label{alg:addingAdditionalNeighbor} \\
   Mark $u$ as visited \\
   $d[u] = 1$ \label{alg:addingAdditionalNeighborEnd} \\
   
   \While{$Q$ is not empty}{
     $u \gets $ first node from $Q$
     
     \ForAll{$w \in N^{\leftarrow}(u)$}{
       \If{$w$ is not marked as visited}{
         $d[w] \gets d[u] + 1$ \\
         Mark $w$ as visited \\
         \If{$d_{old}[w] < d[w]$}{ \label{alg:reverseBFSPruning}
           $A_G^f(u, v) \gets A_G^f(u, v) \cup \{w\}$ \\
           Enqueue $w$ in $Q$
         }
       }
     
     }
     
   }
   
   return $A_G^f(u, v)$ 
   
 \caption{\texttt{PrunedReverseBFS} for edge removals}
\end{algorithm2e}

\begin{figure}[h!]
\centering
\begin{minipage}{.45\textwidth}
  \centering

	\begin{tikzpicture}
	  \tikzset{edge/.style = {-,> = latex'}}
	
      \node[main node,fill=blue!50] (u) {$u$};
      \node[main node,fill=red!50] (v) [below = 2cm of u] {$v$};
      \node[main node,fill=red!30] (u1) [above left = 2cm and 1.5cm of u] {};
      \node[main node,fill=red!30] (u2) [above = 2cm of u] {};
      \node[main node,fill=red!30] (u3) [above right = 2cm and 1.5cm of u] {};
      \node[main node,fill=blue!30] (v1) [below left = 2cm and 1.5cm of v] {};
      \node[main node,fill=blue!30] (v2) [below = 2cm of v] {};
      \node[main node,fill=blue!30] (v3) [below right = 2cm and 1.5cm of v] {};
    
      \draw[dashed] (u) to (v);
      \draw[edge] (u) to (u1);
      \draw[edge] (u) to (u2);
      \draw[edge] (u) to (u3);
      \draw[edge] (v) to (v1);
      \draw[edge] (v) to (v2);
      \draw[edge] (v) to (v3);
    \end{tikzpicture}
  
  \captionof{figure}{Computing affected nodes in undirected graphs}
  \label{fig:affectedNodesUndirectedBfs}
\end{minipage}%
\hspace{0.1\textwidth}%
\begin{minipage}{.45\textwidth}
  \centering
   \begin{tikzpicture}
	\tikzset{edge/.style = {->,> = latex'}}
	
    \node[main node,fill=blue!50] (u) {$u$};
    \node[main node,fill=red!50] (v) [below = 2cm of u] {$v$};
    \node[main node,fill=red!30] (u1) [above left = 2cm and 1.5cm of u] {};
    \node[main node,fill=red!30] (u2) [above = 2cm of u] {};
    \node[main node,fill=red!30] (u3) [above right = 2cm and 1.5cm of u] {};
    \node[main node,fill=white] (v1) [below left = 2cm and 1.5cm of v] {};
    \node[main node,fill=white] (v2) [below = 2cm of v] {};
    \node[main node,fill=white] (v3) [below right = 2cm and 1.5cm of v] {};
    
    \draw[dashed,->] (u) to (v);
    \draw[edge] (u1) to (u);
    \draw[edge] (u2) to (u);
    \draw[edge] (u3) to (u);
    \draw[edge] (v) to (v1);
    \draw[edge] (v) to (v2);
    \draw[edge] (v) to (v3);
    \end{tikzpicture}
    
    \captionof{figure}{Computing affected nodes in directed graphs}
   \label{fig:affectedNodesDirectedBfs}
\end{minipage}
\end{figure}

\subsection{Dynamic Top-k closeness in complex networks}
\label{sec:dynamicTopKOptimizations}
In the following sections, we will describe how our dynamic algorithm reproduces the results of the static algorithm in a more efficient manner by using existing knowledge of the graphs.

\subsubsection{Recomputing the number of reachable nodes}
After an edge modification, it is possible that the number of reachable nodes changes for some nodes in the graph. The dynamic instance of the algorithm should store the connected component each node belongs to. In the case of an edge insertion in undirected graphs, the number of reachable nodes does not change for any node if $u$ and $v$ are in the same component. If they are in different components, the two components are merged and the number of reachable nodes is set to the total number of nodes in the merged component. In all other cases, including edge insertions in directed graphs, we compute the number of reachable nodes (or an upper bound in directed graphs) from scratch. There are algorithms that maintain strongly-connected components in the case of edge removals~\cite{lkacki2013improved,chechik2016decremental}. However, we have not implemented them for this thesis.

\subsubsection{Preserving still-valid information}
We keep a global data structure that stores either the exact closeness centrality or an upper bound for each node like in the static algorithm. During an update operation, we keep a priority queue with the $k$ most central nodes. The exact closeness centralities or computed upper bounds of nodes that are unaffected by an edge modification are still valid after the modification is applied. Therefore, nodes that have previously belonged to the $k$ most central nodes can be re-inserted into the priority queue that manages the Top-k list.

\paragraph{Edge insertions}
In the case of an edge insertion, the closeness centrality of affected nodes can only increase.  We recall that in the static algorithm, the breadth-first search for a given node is aborted if it is clear that the closeness centrality of this node cannot be larger than the closeness centrality of the $k$-th most central node, also denoted as $x_k$ in this thesis. If there is a new member of the Top-k list after the edge insertion, its closeness centrality must be larger than $x_k$ of the old graph. The closeness centrality (or the upper bound) of each affected node in the graph is initially marked as invalid. 

\paragraph{Edge removals}
In the case of an edge removal, the exact closeness centralities of affected nodes become invalid, but upper bounds of affected nodes are still valid. Consider a shortest path $u - v - w$ which is also the only shortest path of length $2$ between $u$ and $w$. If the edge $(u, v)$ is removed, the new shortest path will at least have length $3$. Now consider the harmonic closeness centrality $h(u)$. The contribution of the node pair $(u, w)$ is $\frac{1}{d_G(u, w)} = \frac{1}{2}$ in the unmodified graph. After the edge is removed, the contribution is only $\frac{1}{d_{G'}(u, w)} = \frac{1}{3}$. Since an edge removal does not create any new shorter shortest paths between any pair of nodes, the exact closeness centrality of affected nodes will always be smaller than before. Therefore, all upper bounds of affected nodes are still valid, but now less tight than before. This also allows the following optimization in some cases: if none of the $k$ most central nodes is affected by an edge removal, the update algorithm can be aborted after the computation of the affected nodes. 


\subsubsection{Recomputing closeness centralities after edge insertions}
\label{sec:dynamicComplexRecomputation}
In this section, we will describe Algorithm~\ref{alg:borassiDynamicInsertion} which updates the list of the $k$ most central nodes and their exact closeness centrality after an edge insertion. 

The dynamic algorithm iterates over the affected nodes and recomputes their closeness centralities or an upper bound for their closeness centralities. We can expect that running the algorithm on the initial graph produces upper bounds instead of exact values for at least some of the nodes in the graph. In the following, we will present optimizations that allow us to update these upper bounds without running a new pruned BFS from these nodes. Another optimization allows us to skip nodes if they are far away from the edge insertion. If we cannot apply any of the optimizations, the dynamic algorithm simply performs a new pruned BFS starting from the given node. For algorithm that performs the pruned breadth-first searches in the dynamic case is similar to the one we have presented for the static case. It is outlined in Algorithm~\ref{alg:bfsCutDynamic}. The only difference to the static algorithm is that the dynamic algorithm also returns the level at which a pruned BFS has been aborted as part of the result tuple.


\begin{algorithm2e}[h!]
 \label{alg:bfsCutDynamic}
 \KwData{$G = (V, E), v, x_k$}
 \KwResult{A tuple $(h, \texttt{isExact}, d_{cutoff})$ with $\texttt{isExact} = \texttt{false}$ if $h$ is only an upper bound for the exact harmonic closeness centrality.}
 Create queue $Q$ \\
 $Q$.enqueue($v$) \\
 Mark $v$ as visisted \\
 $d \gets 0; h \gets 0; \widetilde{\gamma} \gets 0; nd \gets 0$ \\
 
 \While{!Q.isEmpty}{
   $u \gets$ Q.dequeue() \\
   \If{$d(v, u) > d$}{ \label{alg:newLevelDynamic}
     $d \gets d + 1$ \\
   	 $r \gets r(u)$ \\
   	 $\widetilde{h} \gets h + \frac{\widetilde{\gamma}}{(d + 1) \cdot (d + 2)} + \frac{r - n_d}{d + 2}$ \label{alg:upperBoundUpdateDynamic} \\
   	 \If{$\widetilde{h} \leq x_k$}{
   	   return $(\widetilde{h}, \texttt{false}, d)$
   	 }
   }
   \ForAll{$w \in N(u)$}{
     \uIf{$w$ is not marked as visited}{
       Mark $w$ as visited \\
       $Q$.enqueue($w$) \\
       $n_d \gets n_d + 1$ \\
       $pred[w] \gets u$ \\
       $d(v, w) \gets d(v, u) + 1$ \\
       $h \gets h + \frac{1}{d(v, w)}$ \label{alg:inverseDistanceSumDynamic} \\
       \eIf{$G$ is directed}{
       		$\widetilde{\gamma} \gets \widetilde{\gamma} + outdegree(w) - 1$\label{alg:gammaUpdateDirectedDynamic}
       }{
       		$\widetilde{\gamma} \gets \widetilde{\gamma} + outdegree(w)$\label{alg:gammaUpdateUndirectedDynamic}
       }
        
     }
     \uElseIf{$d(v, w) > 1 \land pred[u] \neq w$}{ \label{alg:boundAdjustmentDynamic}
     	$\widetilde{h} \gets \widetilde{h} - \frac{1}{d + 1} + \frac{1}{d + 2}$ \\
     	\If{$\widetilde{h} \leq x_k$}{
     		return $(\widetilde{h}, \texttt{false}, d)$
     	}
     }
   }
   return $(h, \texttt{true}, d)$
 }
 
 \caption{\texttt{BFSCut} in the dynamic case}
\end{algorithm2e}

\paragraph{Skipping far-away nodes}
Let $w$ be an arbitrary node in $G$ for which only an upper bound for its closeness centrality is known. We recall that the static algorithm computes the upper bound for the closeness centrality with a pruned breadth-first search. Let $d_{cutoff}(w)$ denote the level at which the previous search was aborted. If the distance of $w$ to the edge modification $d_G^f(w, (u, v))$ is larger than the cutoff level (see Figure~\ref{fig:skipFarAwayNodes}), it is not necessary to run a new pruned BFS. In this case, the search on the modified graph would be completely identical to the previous search on the old graph because the search would be aborted without visiting the modified edge $(u, v)$. Notice that this assumption is only valid if the number of reachable nodes does not change for $w$ due to the edge insertion. If these conditions are met, the dynamic algorithm can mark the old upper bound as valid and skip the expensive recomputation of the upper bound.

Notice that it is possible that the closeness centralities of some nodes will increase after an edge insertion. This can result in a larger closeness centrality of the $k$-th most central node. In this case, a new pruned BFS could be aborted earlier than before because the new threshold is higher. However, $d_{cutoff}(w)$ will never increase after an edge insertion. Therefore, we will sometimes run a new pruned BFS for a node where the new cutoff level is smaller than the distance to the edge insertion.

If we remove edges from the graph, the closeness centralities of some nodes, potentially including the $k$-th most central node, will decrease. This could in theory lead to a later cutoff point for a new pruned BFS. As we will see later, the algorithm for edge removals either keeps the old upper bound or recomputes a new (lower) bound. If the bound is recomputed, we get a new cutoff level. Since we remove edges from the graph in this case, the upper bound obtained with a new pruned BFS up until the cutoff level can never be larger than the old one.

\paragraph{Updating bounds of boundary nodes}
Let $w$ be a node in $G$ for which only an upper bound is known and whose distance to an edge insertion is exactly equal to the cutoff level of the BFS. We then call $w$ \emph{boundary node}. Without loss of generality, we assume that $u$ is always the node closer to the chosen node $w$ and therefore that $d(w, u) = d_{cutoff}(w)$. This scenario is shown in Figure~\ref{fig:cheapBoundUpdate}.

We will now show that the level difference between $u$ and $v$ was at least $2$ before the edge insertion. In consequence, there is one additional node at distance $d_{cutoff}(w) + 1$ after the edge insertion that was previously assumed to be at least at distance $d_{cutoff}(w) + 2$.

\begin{proposition}
\label{prop:minimumDistanceForCheapUpdate}
	\begin{align*}
	 	d_G(w, u) - d_G(w, v) &\geq 2
	\end{align*}
\end{proposition}
\begin{proof}
If the distance in the old graph from $w$ to $u$ was the same as the distance from $w$ to $v$, $w$ would not have been affected by the edge insertion. This is the case because a new path between $w$ and $v$ using the edge $(u, v)$ will always have length $d(w, u) + 1$. This is contradicts the assumption that $d(w, u) = d(w, v)$.

Secondly, if $d_G(w, u) - d_G(w, v) = 1$, then $w$ would also not have been affected by the edge insertion. Similar to the first case, a potential new shortest path between $w$ and $v$ using the edge $(u, v)$ will always have the length $d(w, u) + 1$. Therefore, this new shortest path will at best be as short as an already known shortest path in the old graph. Since the distance between $w$ and $v$ is not decreased by the inserted edge, $w$ would not be affected by the edge insertion. This is again a contradiction of our initial assumption that $w$ is affected.
\end{proof}

The proposition can also be written as
\begin{align}
	d_G(w, v) &\geq d_G(w, u) + 2 = d_{cutoff}(w) + 2.
\end{align}

We recall that Equation~\ref{eq:harmonicClosenessUpperBound} is used to compute the upper bounds for the closeness centrality of a node during the pruned BFS starting from that node. Using Proposition~\ref{prop:minimumDistanceForCheapUpdate}, we can analyze how both $u$ and $v$ contribute to both the old and the new upper bound. Since we assume that $d(w, u) = d_{cutoff}(w)$, the contribution of $u$ to $\widetilde{h}(w)$ is $\frac{1}{d_{cutoff}(w)}$ and will not change due to the edge insertion.

With $d(w, v) \geq d_{cutoff}(w) + 2$, we can deduce that the original contribution of $v$ to $\widetilde{h}(w)$ was $\frac{1}{d_{cutoff}(w) + 2}$. Since we insert $(u, v)$ into the graph, the new distance between $w$ and $v$ will be $d(w, u) + 1$. Thus, the new contribution of $v$ to $\widetilde{h}(w)$ is $\frac{1}{d_{cutoff}(w) + 1}$. In summary, we get
\begin{align}
	\widetilde{h}_{new}(w) = \widetilde{h}_{old}(w) - \frac{1}{d_{cutoff}(w) + 2} + \frac{1}{d_{cutoff}(w) + 1} \label{eq:cheapBoundaryUpdate}.
\end{align}
This allows us to update the upper bound for the closeness centrality of $w$ cheaply and without a new pruned BFS if the updated bound is smaller than the $k$-th largest closeness centrality.


\begin{algorithm2e}[h!]
 \label{alg:borassiDynamicInsertion}
 \KwData{$G = (V, E), (u, v) \notin E$}
 \KwResult{A list with the $k$ nodes with the highest closeness}
 $r_{old}(v) \gets r(v) \quad \forall v \in V$ \\
 Update $r(v)\quad \forall v \in V$ \label{alg:dynamicInsertionPreprocessing}\\
 Compute the set of affected nodes $A(u, v)$ \\
 $d_G^f \gets $ array with the distances to the edge modification for each affected node \\
 
 $x_k \gets \texttt{Top.getMin()}$ \\
 \ForAll{$w \in \texttt{Top}$}{
 	\If{$w \in A(u, v)$}{
 	   \texttt{Top.remove($w$)}
 	}
 }

 \ForAll{$w \in A(u, v)$}{ \label{alg:dynamicInsertionLoop}

	\tcc{Initially, we assume that we need a new pruned BFS for this node}
	$\texttt{newBfs} \gets \texttt{true}$ \\
    
    \uIf{$d_{cutoff}(w) < d_G^f(w) \land \texttt{!isExact}(w) \land r_{old}(w) = r(w)$}{
        \tcc{The inserted edge is beyond the cutoff threshold of the original pruned BFS from $w$. We do not need to do anything to recompute $h(w)$ in this case.}
        $\texttt{newBfs} \gets \texttt{false}$
    }
    \uElseIf{$d_G^f(w) = d_{cutoff}(w) \land !\texttt{isExact}(w) \land r_{old}(w) = r(w)$}{
        \tcc{$w$ is a boundary node and $h(w)$ can be updated cheaply with Equation~\ref{eq:cheapBoundaryUpdate}.}
      $h(w) \gets h(w) - \frac{1}{d_{cutoff}(w) + 2} + \frac{1}{d_{cutoff}(w) + 1}$ \\
      
      \If{$h(w) < x_k$}{
        $\texttt{newBfs} \gets \texttt{false}$
      }
    }
    
    \If{\texttt{newBfs}}{
    	\tcc{No optimization is applicable, we have to perform a new pruned BFS-}
      	$(h, \texttt{isExact}, d_{cutoff}) \gets $ \texttt{BFSCut}($w, x_k$) \\
  	
  	    $h(w) \gets h$\\
  	    $\texttt{isExact}(v) \gets \texttt{isExact}$\\
  	    $d_{cutoff}(w) \gets d_{cutoff}$ \\
    }

  	\If{$isExact \land h(w) > x_k$}{
  	   \texttt{Top.insert($h$, $w$)} \\
  	   \If{$\texttt{Top.size()} > k$}{
	      \texttt{Top.removeMin()}
	   }
	   \If{$\texttt{Top.size()} = k$}{
	     $x_k \gets \texttt{Top.getMin()}$
	   }
	}
 }
 \caption{Recomputation of the $k$ most central nodes after an edge insertion.}
\end{algorithm2e}



\begin{figure}[h!]
\centering
\begin{tikzpicture}
	\tikzset{edge/.style = {->,> = latex'}}
	
    \node[main node] (w) {$w$};
    \node[main node] (w1) [above right = 2cm and 2cm of w] {};
    \node[main node] (w2) [right = 2cm of w] {};
    \node[main node] (w3) [below right = 2cm and 2cm of w] {};
    \node[main node] (w4) [above right = 2cm and 2cm of w1] {};
    \node[main node] (w5) [below right = 2cm and 2cm of w3] {};
    \node[main node] (w6) [below right = 2cm and 2cm of w2] {};
    \node[main node] (w7) [right = 2cm of w2] {};
    \node[main node] (w8) [above right = 2cm and 2cm of w2] {};
    
    \node[main node,fill=red!50] (u) [right = 3cm of w8] {$u$};
    \node[main node,fill=red!50] (v) [below right = 2cm and 1cm of u] {$v$};
    
    \coordinate[above right = 1cm and 0.5cm of w4] (d1);
    \coordinate[below right = 1cm and 0.5cm of w5] (d2);
    
    \draw[edge] (w) to (w1);
    \draw[edge] (w) to (w2);
    \draw[edge] (w) to (w3);
    \draw[edge] (w1) to (w4);
    \draw[edge] (w2) to (w6);
    \draw[edge] (w2) to (w7);
    \draw[edge] (w2) to (w8);
    \draw[edge] (w3) to (w5);
    
    \draw[dashed] (u) to (v);
    
    \draw[dotted,very thick] (d1) to [bend left] (d2);
    
\end{tikzpicture}
\caption{Skipping far-way nodes}{The dotted line divides the nodes which were visited during the pruned BFS from $w$ from the nodes whose distance was only estimated with a lower bound. If the modified edge is beyond the dotted line, it does not reduce the distance of $w$ to any node for which an exact distance was computed with the pruned BFS.}
\label{fig:skipFarAwayNodes}
\end{figure}

\begin{figure}[h!]
\centering
\begin{tikzpicture}
	\tikzset{edge/.style = {->,> = latex'}}
	
    \node[main node] (w) {$w$};
    \node[main node] (w1) [above right = 2cm and 2cm of w] {};
    \node[main node] (w2) [right = 2cm of w] {};
    \node[main node] (w3) [below right = 2cm and 2cm of w] {};
    \node[main node] (u) [above right = 2cm and 2cm of w1] {$u$};
    \node[main node] (w5) [below right = 2cm and 2cm of w3] {};
    \node[main node] (w6) [below right = 2cm and 2cm of w2] {};
    \node[main node] (w7) [right = 2cm of w2] {};
    \node[main node] (w8) [above right = 2cm and 2cm of w2] {};
    
    \node[main node,fill=red!50] (v) [right = 3cm of u] {$v$};
    
    \coordinate[above right = 1cm and 0.5cm of w4] (d1);
    \coordinate[below right = 1cm and 0.5cm of w5] (d2);
    
    \draw[edge] (w) to (w1);
    \draw[edge] (w) to (w2);
    \draw[edge] (w) to (w3);
    \draw[edge] (w1) to (u);
    \draw[edge] (w2) to (w6);
    \draw[edge] (w2) to (w7);
    \draw[edge] (w2) to (w8);
    \draw[edge] (w3) to (w5);
    
    \draw[dashed] (u) to (v);
    
    \draw[dotted,very thick] (d1) to [bend left] (d2);
    
\end{tikzpicture}
\caption{Improving upper bounds without an additional BFS}{The dotted line divides the nodes which were visited during the pruned BFS from $w$ from the nodes whose distance was only estimated with a lower bound. If $u$ is exactly on the last level before the boundary and $v$ is beyond the boundary, the impact of that edge insertion can be computed without performing a new pruned BFS.}
\label{fig:cheapBoundUpdate}
\end{figure}

\subsubsection{Recomputing closeness centralities after edge removals}
\label{sec:dynamicTopClosenessRemoval}
As we have already discussed earlier, the upper bounds of affected nodes remain valid after an edge is removed from the graph. Algorithm~\ref{alg:borassiDynamicRemoval} outlines the steps necessary to update the $k$ most central nodes and their closeness centralities after an edge removal. As in the edge insertion case, the algorithm first computes the set of affected nodes. Since the closeness centralities of affected nodes can only decrease, existing upper bounds stay valid and exact closeness centralities become upper bounds. Therefore, we mark the current closeness centrality of each affected node as an upper bound in Line~\ref{alg:dynamicRemovalNewUpperBounds}. The algorithm starts with an empty priority queue \texttt{Top} which manages the $k$ most central nodes  (Line~\ref{alg:dynamicRemovalTop}).

In contrast to the algorithm for edge insertions, the algorithm for edge removals iterates over all the nodes in the graph in decreasing order of their previous closeness centrality (Line~\ref{alg:dynamicRemovalLoop}). If \texttt{Top} already contains $k$ nodes and the closeness centrality of the $k$-th node is larger than the old closeness centrality or upper bound of $w$, the loop can be aborted (Line~\ref{alg:dynamicRemovalBreak}). This is possible since edge removals can only reduce the closeness centralities of nodes in the graph. Therefore, there cannot be any nodes that ``jump the queue'' as in the case of an edge insertion.

If the there is an exact value for the closeness centrality of $w$ and, it can be added to \texttt{Top} immediately and it is not necessary to start a new pruned BFS. Otherwise, the algorithm executes a pruned BFS to obtain a new upper bound or the exact closeness centrality for $w$. If the BFS yields the exact closeness centrality, $w$ is added to \texttt{Top}.

\begin{algorithm2e}[h!]
 \label{alg:borassiDynamicRemoval}
 \KwData{$G = (V, E), (u, v) \notin E$}
 \KwResult{A list with the $k$ nodes with the highest closeness}
 Update $r(v)\quad \forall v \in V$ \label{alg:dynamicRemovalPreprocessing}\\
 Compute the set of affected nodes $A(u, v)$ \\
 
 \ForEach{$w \in A(u, v)$}{
   \texttt{isExact[$w$]} $ \gets \texttt{false}$ \label{alg:dynamicRemovalNewUpperBounds}
 }
  
 $x_k \gets 0$ \\ 
 $\texttt{Top} \gets $ empty priority queue \label{alg:dynamicRemovalTop} \\
 
 \ForAll{$w \in V$ in decreasing order of $\widetilde{h}_{old}(w)$}{ \label{alg:dynamicRemovalLoop}
     
   
    \If{$\texttt{Top.size()} = k \land h(w) < x_k$}{ \label{alg:dynamicRemovalBreak}
      \texttt{break;}
    }
    
    \If{\texttt{!isExact[$w$]}}{
       \texttt{Top.insert($h(w)$, $w$)} \\
  	   \If{$\texttt{Top.size()} > k$}{
	      \texttt{Top.removeMin()}
	   }
	   \If{$\texttt{Top.size()} = k$}{
	     $x_k \gets \texttt{Top.getMin()}$
	   }
	   \texttt{continue;}
    }

    \tcc{Recompute the closeness centrality of the node}
    $(h, \texttt{isExact}, d_{cutoff}) \gets $ \texttt{BFSCut}($w, x_k$) \\
    $h(w) \gets h$\\
    $\texttt{isExact}(v) \gets \texttt{isExact}$\\
    $d_{cutoff}(w) \gets d_{cutoff}$ \\
    
    \If{$isExact \land h > x_k$}{
      \texttt{Top.insert($h$, $w$)} \\
      \If{$\texttt{Top.size()} > k$}{
        \texttt{Top.removeMin()}
       }
       \If{$\texttt{Top.size()} = k$}{
         $x_k \gets \texttt{Top.getMin()}$
       }
     }
 }
 \caption{Recomputation of the $k$ most central nodes after an edge removal.}
\end{algorithm2e}

\FloatBarrier

\subsection{Dynamic closeness centrality in networks with large diameters}
We recall that the algorithm for complex networks performs a pruned BFS from every single node in the graph. On the contrary, the algorithm for street networks always performs a complete BFS for some nodes in order to compute upper bounds for all the other nodes in the graph (Section~\ref{sec:largeDiameterStatic}, Algorithm~\ref{alg:streetNetworksStatic}). Since there is either a complete BFS or no BFS at all for each node, there is no cutoff level that could be used to skip far-away nodes after an edge insertion or to update the upper bounds of boundary nodes cheaply. However, it is possible to compute an upper bound for the \emph{improvement} of the closeness centrality of each node after an edge insertion. In the case of edge removals, we use the same algorithm for street networks as we do for complex networks (see Section~\ref{sec:dynamicTopClosenessRemoval}).

\subsubsection{Level-based improvement bounds}
\label{sec:levelBasedImprovementBounds}
Let $(u, v)$ denote an edge that is inserted into a graph $G$ to create $G'$. We will at first only consider directed graphs, but the optimization can be easily adapted to undirected graphs by executing the same steps for both $u$ and $v$.  Let $S_{x} = \{t : d_{G'}(x, t) < d_G(x, t)\}$ denote the set of \emph{affected sink nodes} of $x$, i.e. the set of endpoints of paths starting in $x$ that are shorter in $G'$ than in $G$. Let $\Phi_{G}^i = \{t : d_G(u, t) = i\}$ denote the set of nodes with distance $i$ from node $u$ in $G$, $\Phi_{G'}î$ denotes the same set in $G'$.

As we already noted earlier, each new shortest path in the graph must contain the edge $(u, v)$. For any new path $x - ... - u - v - ... - t$ the subpath $u - v - ... - t$ is also a new shortest path. On the other hand, there could be a node $x$ which already has a shorter path to at least one of the sink nodes of $u$ that does not use the edge $(u, v)$. Therefore, $S_x \subseteq S_u$ for all $x \in V \setminus \{u\}$.

\begin{definition}
The improvement for the closeness centrality of $u$ after the insertion of the edge $(u, v)$ is 
\begin{align}
	h_{impr}(u) &= h_{new}(u) - h_{old}(u) \nonumber \\
	            &= \sum_{t \in S_u}{\frac{1}{d_{G'}(u, t)} - \frac{1}{d_G(u, t)}} \nonumber \\
	            &= \sum_{i}{\frac{1}{i} \cdot \left(\Phi_{G'}^i - \Phi_G^i\right)} \label{eq:levelImprovementBound}.
\end{align}
\end{definition}

\begin{definition}
The improvement of the contribution of the node pair $(x, w)$ to the closeness centrality of $x$ after the insertion of the edge $(u, v)$ is 
\begin{align}
	h_{impr}(x, w) = \frac{1}{d_{G'}(x, w)} - \frac{1}{d_{G}(x, w)}
\end{align}
\end{definition}

We will now show that $h_{impr}(u)$ is an upper bound for the improvement of the closeness centrality of \emph{all} affected nodes. First, we consider the contribution to the improvement of an affected node $x$ and a corresponding sink node $w$. We want to show that 
\begin{align}
	h_{impr}(u, w) &\geq h_{impr}(x, w) \nonumber \\
	\iff \frac{1}{d_{G'}(u, w)} - \frac{1}{d_{G}(u, w)} &\geq \frac{1}{d_{G'}(x, w)} - \frac{1}{d_{G}(x, w)} \label{eq:contributionImprovement}.
\end{align}
In the old graph, a shortest path between $x$ and $w$ either contains $u$ or it does not. In either case, $d_G(x, w) > d_G(u, w)$ because otherwise $x$ would not be an affected node. Since the new shortest path will contain the edge $(u, v)$, we also know that $d_{G'}(x, w) > d_{G'}(u, w)$. However, we cannot guarantee that $d_G(u, w) < d_G(x, w)$, since there could be a shorter path from $x$ to $w$ in $G$ that does not contain $u$.

We define $\Delta(u) := d_G(u, w) - d_{G'}(u, w)$ and $\Delta(x) := d_G(x, w) - d_{G'}(x, w)$. We rewrite Equation~\ref{eq:contributionImprovement}:
\begin{align}
	\frac{1}{d_{G'}(u, w)} - \frac{1}{d_{G'}(u, w) + \Delta(u)} &\geq \frac{1}{d_{G'}(x, w)} - \frac{1}{d_{G'}(x, w) + \Delta(x)}
\end{align}

Since it is possible that the shortest path from $x$ to $w$ in $G$ does not contain $u$, we can state that $\Delta(x) \leq \Delta(u)$. In practical terms, this means that the improvement of the distance of all affected nodes $x$ is at most as large as it is for $u$. If the shortest path in the old graph contains $u$, the distance improvement for $u$ and $x$ to $w$ is exactly the same. Otherwise, it is possible that the distance improvement for $x$ is smaller since $d_G(x, w) < d_G(x, u) + d_G(u, w)$.

Since $\Delta(x)$, $\Delta(u)$ and all the distances are larger than $0$, we only have to show that the inequality holds for $\Delta(x) \in [0, \Delta(u)]$. For $\Delta(x) = 0$ we get the inequality
\begin{align*}
	\frac{1}{d_{G'}(u, w)} - \frac{1}{d_{G'}(u, w) + \Delta(u)} &\geq \frac{1}{d_{G'}(x, w)} - \frac{1}{d_{G'}(x, w) + 0} \\
	\frac{1}{d_{G'}(u, w)} - \frac{1}{d_{G'}(u, w) + \Delta(u)} &\geq 0
\end{align*} 
which trivially holds. In the other case, we set $\Delta(x) = \Delta(u)$ and get
\begin{align*}
	\frac{1}{d_{G'}(u, w)} - \frac{1}{d_{G'}(u, w) + \Delta(u)} &\geq \frac{1}{d_{G'}(x, w)} - \frac{1}{d_{G'}(x, w) + \Delta(u)} 
\end{align*}
which also holds if all the terms are positive.

Since we now know that $h_{impr}(x, w) \leq h_{impr}(u, w)$ for any affected node $x$ and a given sink node $w$, and that $|S_x| \leq |S_u|$, we can conclude that $h_{impr}(x) \leq h_{impr}(u)$ for any affected node $x$. 

We can improve this upper bound for $h_{impr}(x)$ further. We know that the new shortest path between $x$ and $w$ contains the inserted edge $(u, v)$, and thus $d_{G'}(x, w) = d_{G'}(x, u) + d_{G'}(u, w)$. Equation~\ref{eq:levelImprovementBound} can be used to compute the improvement of $u$. However, this bound is not as tight as it could be for nodes which are further away from the edge insertion than $u$. For instance, it does make a larger difference for the harmonic closeness centrality if the distance between two nodes changes from $3$ to $2$ than it does if the distance changes from $8$ to $7$, since $\frac{1}{2} - \frac{1}{3} > \frac{1}{7} - \frac{1}{8}$. We can adapt Equation~\ref{eq:levelImprovementBound} to provide an upper bound for the improvement for nodes with distance $j$ to the edge insertion:
\begin{align}
	h_{impr,LB}(j) = \sum_{i}{\frac{1}{i + j} \cdot \left(\Phi_{G'}^i \cdot - \Phi_G^i\right)}.
\end{align}

Figure~\ref{fig:levelBasedImprovementBounds} shows an example how level-based improvement bounds work. We insert an edge between $u$ and $v$ into a directed graph. Sink nodes are marked in blue, affected nodes in a shade of yellow (excluding $u$, which is also affected). While node $u$ has a new shortest path to each of the sink nodes, there are affected nodes like $u_1$ and $u_3$ which already have a shorter path to some of the sink nodes. The further an affected node is from the inserted edge, the smaller is the maximum improvement. This is indicated by a lighter shade of yellow in the figure.


\paragraph{Computing level-based improvement bounds}
In order to use level-based improvement bounds, we need to compute $\Phi_G^i$ and $\Phi_{G'}^i$. This can be done with two breadth-first searches on $G$ and $G'$ starting in $u$. On undirected graphs, the algorithm to compute the affected nodes of an edge insertion already computes the distances of all nodes to $u$ in both $G$ and $G'$. Knowing the distances $d_G(u, w)$ and $d_{G'}(u, w)$ for each node $w$ allows us to count the number of nodes with each distinct distance. In the directed case, we need to to perform an additional forward BFS from $u$ in order to compute the distances and then $\Phi_G^i$ and $\Phi_{G'}^i$.

Algorithm~\ref{alg:levelBasedImprovementBounds} outlines the steps to compute the level-based improvement bounds in a directed graph.

\subparagraph{Complex networks}
We have also integrated this optimization in our dynamic algorithm for edge insertions in complex networks. We add the level-based improvement bound to the old closeness centrality of a node if the other two optimizations, skipping far-away nodes and cheaply updating boundary nodes, cannot be applied. If the resulting upper bound is smaller than the closeness centrality of the $k$-th most central node, we do not need to run a new pruned BFS for this node.

\subsubsection{Recomputing closeness centralities after edge insertions}
The algorithm that updates closeness centralities in networks with large diameters after edge insertions is based on the static algorithm for the problem which was presented in Section~\ref{sec:largeDiameterStatic}. Algorithm~\ref{alg:streetNetworksDynamic} outlines the dynamic algorithm. First, the affected nodes and the maximum possible improvement of the closeness centrality of each affected node are computed (Line~\ref{alg:computeAffectedNodesStreetNetworks} and~\ref{alg:computeImprovement}). As in the dynamic algorithm for complex networks, affected nodes are removed from the priority queue \texttt{Top} which manages the $k$ most central nodes (Line~\ref{alg:removeAffectedNodesFromTopQueue}). The computed maximum improvement for each node is added in Line~\ref{alg:addImprovementDynamic}.

The algorithm then iterates over each affected node $w$ (Line~\ref{alg:streetNetworksLoopDynamic}). If the current known upper bound in \texttt{score} is smaller than the exact closeness centrality of the $k$-th most central node, the recomputation step can be skipped (Line~\ref{alg:skipNodesStreetNetworksDynamic}). Otherwise, the algorithm handles $w$ exactly as in the static case. It computes the exact closeness of $w$ (Line~\ref{alg:updateBoundsCallDynamic}) and updates the upper bounds of other nodes in the graph if possible (Line~\ref{alg:updateScoresDynamic}). At last, the \texttt{Top} queue is updated if $w$ has a larger exact closeness centrality than the current $k$-th most central node.

\begin{algorithm2e}[h!]
 \label{alg:levelBasedImprovementBounds}
 \KwData{$G = (V, E), (u, v) \notin G$}
 \KwResult{$h_{impr}(w) \forall w \in A(u, v)$}
 
 $G' \gets G \cup \{u, v\} $ \\
 $A(u, v) \gets \texttt{AffectedNodes}(u, v)$ \\
 $d_{G} \gets $ BFS from $u$ in $G$ \\
 $d_{G'} \gets $ BFS from $u$ in $G'$ \\
 $\Delta \gets max\;d^-$
 
 \tcc{Count the number of nodes on each level from $u$}
 \For{$i \leq \Delta$}{
   $\Phi_G^i \gets \left|\left\{w \in V \mid d_G(w) = i\right\}\right|$ \\
   $\Phi_{G'}^i \gets \left|\{w \in V \mid d_{G'}(w) = i\}\right|$ \\
 }
 
 \tcc{Compute the improvement bound for each level}
 \For{$1 \leq i \leq \Delta$}{
   $h_{impr,LB}(i) \gets 0$ \\
   \For{$1 \leq j \leq \Delta$}{
     $h_{impr,LB}(i) \gets h_{impr,LB}(i) + \frac{1}{i + j} \cdot (\Phi_{G'}^j - \Phi_{G}^j)$
   }  
 }
 
 \tcc{Select the correct bound for each affected node based on its distance to $u$}
 $d_{reverse} \gets $ reverse BFS from $u$
 \ForEach{$w \in A(u, v)$}{
   $h_{impr}(w) \gets h_{impr,LB}(d_{reverse}(w))$
 }
 

 \caption{Computation of the level-based improvement bound for each affected node in a directed graph}
\end{algorithm2e}

\begin{algorithm2e}[h!]
 \label{alg:streetNetworksDynamic}
 \KwData{$G = (V, E), (u, v) \notin G$}
 \KwResult{A list with the $k$ nodes with the highest closeness}
 
 Compute the set of affected nodes $A(u, v)$ \label{alg:computeAffectedNodesStreetNetworks} \\
 $\texttt{maxImprovement} \gets $ level-based improvement for each node with Algorithm~\ref{alg:levelBasedImprovementBounds} \label{alg:computeImprovement} \\
 
 \texttt{Q} $\gets A(u, v)$, sorted by decreasing previous upper bound for the closeness centrality \\
 \texttt{score} $\gets $ array indexed by node ID storing the current upper bounds for all nodes
 
 \ForAll{$w \in \texttt{Top}$}{
 	\If{$w \in A(u, v)$}{
 	   \texttt{Top.remove($w$)} \label{alg:removeAffectedNodesFromTopQueue}
 	}
 	
 	\texttt{score[$w$]} $ \gets $ \texttt{score[$w$]} $ + $ \texttt{maxImprovement[$w$]} \label{alg:addImprovementDynamic} \\
 }
 
 \While{$Q$ is not empty}{ \label{alg:streetNetworksLoopDynamic}
   $v \gets \texttt{Q.extractMax()}$ \label{alg:streetNetworksExtractionDynamic} \\

   \If{\texttt{score[$v$]}$ \leq $ \texttt{Top[$k$]}}{
     \texttt{continue;} \label{alg:skipNodesStreetNetworksDynamic}
   } 
   
   \texttt{levelBasedBounds} $\gets $ \texttt{updateBounds($v$)} \label{alg:updateBoundsCallDynamic} \\
   $\texttt{score[v]} \gets \texttt{levelBasedBounds[v]}$ \\
   
   \ForAll{$w \in V$}{ \label{alg:updateScoresDynamic}
     \If{\texttt{levelBasedBounds}[$w$] $<$ \texttt{score[$w$]}}{
       \texttt{score[$w$]} $\gets $ \texttt{levelBasedBounds}[$w$]
     }
   }
   
   \If{\texttt{score[$v$]} > \texttt{Top[$k$]}}{ \label{alg:updateTopDynamic}
      add $v$ to \texttt{Top} \\
   	  sort \texttt{Top} by \texttt{score} and reduce it to at most $k$ elements
   }
   re-order \texttt{Q} according to the new values in \texttt{score}
 }
 \caption{Dynamic recomputation of the $k$ nodes with the highest closeness centrality in networks with large diameter after an edge insertion.}
\end{algorithm2e}


\begin{figure}[h!]
\centering
\begin{tikzpicture}
	\tikzset{edge/.style = {->,> = latex'}}
	\tikzset{inserted/.style = {thick,dotted,->,> = latex'}}
	\tikzstyle level1=[main node,fill=yellow!80];
	\tikzstyle oldShortestPath=[main node,fill=white];
	\tikzstyle level2=[main node,fill=yellow!30];
	
    \node[main node,fill=red!50] (u) {$u$};
    \node[main node,fill=red!50] (v) [below = 2cm of u] {$v$};
    
    \node[oldShortestPath] (o1) [below left = 0.71cm and 0.71cm of u] {};
    \node[oldShortestPath] (o2) [below right = 0.71cm and 0.71cm of u] {};
    
    \node[level1] (u1) [above left = 2cm and 2cm of u] {$u_1$};
    \node[level1] (u2) [above = 2cm of u] {};
    \node[level1] (u3) [above right = 2cm and 2cm of u] {$u_3$};
    
    \node[level2] (u4) [above left = 2cm and 2cm of u1] {};
    \node[level2] (u5) [above = 2cm of u2] {};
    \node[level2] (u6) [above right = 2cm and 2cm of u3] {};
    
    \node[main node] (v1) [below left = 2cm and 2cm of v] {};
    \node[main node] (v2) [below = 2cm of v] {};
    \node[main node] (v3) [below right = 2cm and 2cm of v] {};
     
    \node[main node] (v4) [below left = 2cm and 2cm of v1] {};
    \node[main node] (v5) [below = 2cm of v2] {};
    \node[main node] (v6) [below right = 2cm and 2cm of v3] {};
    
    
    \draw[inserted] (u) to (v);
    \draw[edge] (u1) to (u);
    \draw[edge] (u2) to (u);
    \draw[edge] (u3) to (u);
    
    \draw[edge] (u4) to (u1);
    \draw[edge] (u5) to (u2);
    \draw[edge] (u6) to (u3);
    
    \draw[edge] (u) to (o1);
    \draw[edge] (u) to (o2);
    \draw[edge] (o1) to (v);
    \draw[edge] (o2) to (v);
    
    \draw[edge] (v) to (v1);
    \draw[edge] (v) to (v2);
    \draw[edge] (v) to (v3);
    
    
    \draw[edge] (v1) to (v4);
    \draw[edge] (v2) to (v5);
    \draw[edge] (v3) to (v6);
    
    \draw[edge] (u1) to (v1);
    \draw[edge] (u3) to (v3);
    	
\end{tikzpicture}
\caption{Level-based improvement bounds}{}
\label{fig:levelBasedImprovementBounds}
\end{figure}


