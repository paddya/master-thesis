%% introduction.tex
%%

%% ==============================
\chapter{Introduction}
\label{ch:Introduction}
%% ==============================

The concept of a \emph{network} is used as a tool to model interactions and connections in several fields of science. ``The scientific study of networks \textelp{} is an interdisciplinary field that combines ideas from mathematics, physics, biology, computer science, the social sciences and many other areas'', Mark Newman writes in his book \emph{Networks. An introduction}~\cite{newmannetworks}.   

One fundamental concept in network analysis is \emph{Centrality}. Centrality measures are used to ascertain the importance of nodes within a graph. Practical applications include finding the most influential people in a social network~\cite{FREEMAN1978215}, identifying key infrastructure nodes in computer networks, analyzing the effects of human land use to organism movement~\cite{estrada2008using}, or finding so-called super-spreaders in disease transmission networks~\cite{dekker2013network}. 

One of the most widely-known centrality measures is \emph{PageRank}, proposed by the founders of Google, Sergey Brin and Larry Page~\cite{page1999pagerank}. The idea behind PageRank is that a webpage is important if it is linked to by other important webpages. Instead of simply relying on the absolute number of links to a webpage (a metric that was often used in citation networks), the quality of the links is taken into account. PageRank is similar to Eigenvector centrality. At the time, PageRank was a considerable improvement over other search engines.

Another popular centrality measure is called Betweenness Centrality. A node is important if it is part of many shortest paths between other node pairs. For instance, this can be useful to find the routers in a computer network that are most integral to its stability.

\paragraph{Closeness centrality}
Closeness centrality is based on the intuition, first presented by Alexander Bavelas in 1950~\cite{bavelas1950communication}, that a node is important if its distance to other nodes in the graph is small. There are different definitions of closeness centrality that are applicable in different contexts. For strongly connected graphs, one can simply compute the sum of the distances from one node to all the other nodes and compute the inverse value. However, this approach leads to problems on disconnected graphs. It is not initially clear how to treat nodes which are not connected by a path in the graph. Simply assuming an infinite (or arbitrarily large) distance would completely distort the resulting closeness values of affected nodes, since closeness centrality involves computing the sum of distances to other nodes. Arbitrarily large or infinite terms automatically lead to a sum total that is arbitrarily large and therefore loses any informative value. One possible solution for this problem is to only take into account the distances of reachable nodes, then scaling the result with the number of reachable nodes. Another approach is called \emph{harmonic closeness centrality} which has been shown to have nice properties on arbitrary graphs~\cite{boldi2014axioms}. Instead of summing all distances and then computing the inverse, the harmonic closeness centrality is obtained by computing the sum of the inverse distances between nodes. Disconnected node pairs do not contribute to the total sum of inverse distances.

Computing the closeness centrality of a node in an unweighted graph requires a complete breadth-first search (BFS), and a complete run of Dijkstra's algorithm~\cite{dijkstra1959note} with weighted graphs. It requires solving the \emph{all-pairs-shortest-path} problem to compute the closeness centrality of each node in the graph. The computational effort for this is often impractical, especially on large real-world networks. Unfortunately, this effort cannot be avoided if the application requires the exact closeness ranking of all nodes.

For some applications, however, it is enough to compute a list of the $k$ most central nodes. This problem is called Top-$k$ closeness centrality. Limiting the problem to the $k$ most central nodes can decrease the required computational effort significantly in real-world networks. 

The idea of existing approaches~\cite{borassi2015fast,bergamini2016computing} is to compute upper bounds on the closeness of each node. If we find $k$ nodes whose closeness is higher than the upper bounds on the remaining nodes, we know these nodes have to be the top-$k$ (and we do not need to compute the exact closeness of the other nodes). Notice that, although these approaches were shown to work very well in practice, they are not asymptotically faster than computing closeness for all nodes. However, Bergamini et al.~\cite{bergamini2016computing} have shown that the most central node in a graph cannot be computed in $\mathcal{O}(|E|^{2 - \epsilon})$ in directed graphs in the worst-case, under reasonable complexity assumptions.


%\todo{Mention algorithms for dynamic closeness}

\paragraph{Dynamic Top-$k$ closeness centrality}

In some cases, it is enough to compute closeness centralities only once because the underlying graph is static. Now consider a social network which constantly adds new users, which is effectively a node insertion in the underlying graph, and existing users befriend other users, which is an edge insertion. Terminating a friendship in the social network corresponds to an edge removal.

Each modification of an undirected graph affects at least the closeness centralities of the directly affected nodes, that is, the nodes incident to a newly inserted or removed edge. In directed graphs, only the source node of the directed edge is directly affected. It is also possible that there are new shortest paths between pairs of nodes that use the newly inserted edge. Analogously, removing an edge might increase the distance between node pairs because every shortest path between them contained the removed edge. A simple strategy to get the new closeness centralities of each node is to re-run the static algorithm on the modified graph, ignoring any information collected by previous runs of the algorithm.

\paragraph{Group closeness}
The concept of closeness centralities for single nodes can be extended to groups of nodes. The distance between a node $v$ and a group $S$ is defined as the smallest distance between $v$ and any node of the group. The problem to find a group of size $k$ such that the total distance of all nodes in the graph to the group is minimal is called the \emph{maximum closeness centrality group identification} (MCGI) problem by Chen et al.\ in~\cite{Chen2016}. Since the problem is shown to be NP-hard, no efficient exact algorithm exists at this point. However, there are approximative greedy algorithms~\cite{Chen2016,zhao2014measuring} for the problem. Bergamini et al.~\cite{bergaminiGroupCloseness} improve on the work in~\cite{Chen2016} by reducing the memory requirements and total number of operations.

\paragraph{Types of networks}

In this thesis, we will work with two types of networks and will adapt our algorithms to exploit their individual structure. 

\emph{Complex networks} are usually highly irregular graphs that exhibit the \emph{small-world phenomenon}~\cite{wang2003complex}. These networks have very few nodes that have high degree (\emph{hubs}) and a vast majority of nodes with comparably low degree. The degree distribution follows a \emph{power law}, i.e. the amount of nodes with degree $k$ is proportional to $k^{-\gamma}$ where $\gamma$ is a positive constant. Since many nodes have a connection to at least one hub, these complex networks often have a small diameter (``small world''). Social networks like Twitter or Facebook have underlying social graphs with this structure.

\emph{Street networks} are based on real-world infrastructure and model the roads of a certain region. They have a large diameter compared to complex networks and hubs are not as distinguishable from other nodes.


\paragraph{Contributions}
This thesis contributes a dynamic algorithm for Top-$k$ closeness that handles both edge insertions and edge removals. It is based on the static algorithm first proposed by Borassi et al for complex networks in ~\cite{borassi2015fast}, and the additional optimizations for street networks proposed by Bergamini et al.\ in ~\cite{bergamini2016computing}. Our algorithm re-uses information obtained by an initial run of the static algorithm and tries to skip the re-computation of closeness centralities for nodes that are unaffected by modifications of the graph. In some cases, even the upper bounds for the closeness centralities of affected nodes can be updated with little computational effort. In contrast to other dynamic algorithms for closeness centrality, it is not required to compute the exact closeness centralities of all nodes in the graph. Our dynamic algorithms require only a linear amount of additional memory.

We also contribute an algorithm to update the group of nodes with the highest group closeness after an edge insertion. It is based on the work by Bergamini et al.\ who improved the algorithm by Chen et al. Our basic idea is to verify whether the choices of the greedy algorithm are still valid on the modified graph with as little computational effort as possible. Once the greedy algorithm would choose a different node than on the previous graph, the dynamic algorithm discards all information from the previous run and falls back to the static algorithm.

All our dynamic algorithms are based on existing implementations in NetworKit which is an open-source toolkit for high-performance network analysis~\cite{staudt2014networkit}. In experiments, we obtain significant speedups compared to static recomputation. For instance, our dynamic algorithm for top-$k$ closeness centrality is about 40 times faster on average on undirected complex networks. For directed street networks, we reach speedups of up to 140 on average. Our dynamic group closeness algorithm is between 8 and 15 times faster on average, depending on the group size.

\paragraph{Outline}
In Chapter~\ref{ch:preliminaries}, we will provide basic definitions. Chapter~\ref{ch:staticCloseness} contains a description of the static algorithms for Top-$k$ closeness centrality in complex networks and street networks. We will adapt these algorithms for dynamic graphs in Chapter~\ref{ch:dynamicCloseness}. In Chapter~\ref{ch:groupCloseness}, we will make use of our dynamic algorithm for Top-$k$ closeness centrality and describe a dynamic algorithm for the group closeness problem. Chapter~\ref{ch:implementation} describes our implementation in NetworKit and provides some additional implementation details. We evaluate our dynamic algorithms and compare them to static recomputation in Chapter~\ref{ch:experiments}. We conclude with Chapter~\ref{ch:conclusion} and provide some ideas for future work.